<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Patrick Cloke - celery</title><link>https://patrick.cloke.us/</link><description></description><lastBuildDate>Fri, 15 Sep 2023 15:28:00 -0400</lastBuildDate><item><title>Celery architecture breakdown</title><link>https://patrick.cloke.us/posts/2023/09/15/celery-architecture-breakdown/</link><description>
&lt;p&gt;The &lt;a class="reference external" href="https://docs.celeryq.dev/en/v5.2.7/"&gt;Celery project&lt;/a&gt;, which is often used Python library to run “background tasks”
for synchronous web frameworks, describes itself as:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Celery is a simple, flexible, and reliable distributed system to process vast
amounts of messages , while providing operations with the tools required to
maintain such a system.&lt;/p&gt;
&lt;p&gt;It’s a task queue with focus on real-time processing, while also supporting
task scheduling.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The documentation goes into great detail about how to configure Celery with
its plethora of options, but it does not focus much on the &lt;a class="reference external" href="https://docs.celeryq.dev/en/v5.2.7/getting-started/introduction.html"&gt;high level architecture&lt;/a&gt;
or how messages pass between the components. Celery is &lt;em&gt;extremely&lt;/em&gt; flexible (almost
every component can be easily replaced!) but this can make it hard to understand.
I attempt to break it down to the best of my understanding below. &lt;a class="footnote-reference" href="#id7" id="id1"&gt;[1]&lt;/a&gt;&lt;/p&gt;
&lt;div class="section" id="high-level-architecture"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id17"&gt;High Level Architecture&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Celery has a few main components &lt;a class="footnote-reference" href="#id8" id="id2"&gt;[2]&lt;/a&gt;:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Your application code, including any &lt;a class="reference external" href="https://docs.celeryq.dev/en/v5.2.7/userguide/tasks.html"&gt;&lt;tt class="docutils literal"&gt;Task&lt;/tt&gt;&lt;/a&gt; objects you’ve defined. (Usually
called the “client” in Celery’s documentation.)&lt;/li&gt;
&lt;li&gt;A &lt;a class="reference external" href="https://docs.celeryq.dev/en/v5.2.7/getting-started/backends-and-brokers/index.html"&gt;broker&lt;/a&gt; or message transport.&lt;/li&gt;
&lt;li&gt;One or more Celery &lt;a class="reference external" href="https://docs.celeryq.dev/en/v5.2.7/internals/worker.html"&gt;workers&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;A (results) &lt;a class="reference external" href="https://docs.celeryq.dev/en/v5.2.7/getting-started/backends-and-brokers/index.html"&gt;backend&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote class="text-center"&gt;
&lt;a class="reference external image-reference" href="https://patrick.cloke.us/images/celery-architecture/celery-overview.png"&gt;&lt;img alt="Celery overview" src="https://patrick.cloke.us/images/celery-architecture/celery-overview.png" style="width: 50%;"/&gt;&lt;/a&gt;
&lt;p&gt;A simplified view of Celery components.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In order to use Celery you need to:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Instantiate a Celery &lt;tt class="docutils literal"&gt;application&lt;/tt&gt; (which includes configuration, such as
which broker and backend to use and how to connect to them) and define one or
more &lt;tt class="docutils literal"&gt;Task&lt;/tt&gt; definitions.&lt;/li&gt;
&lt;li&gt;Run a broker.&lt;/li&gt;
&lt;li&gt;Run one or more Celery workers.&lt;/li&gt;
&lt;li&gt;(Maybe) run a backend.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If you’re unfamiliar with Celery, below is an example. It declares a simple
&lt;tt class="docutils literal"&gt;add&lt;/tt&gt; task using the &lt;tt class="docutils literal"&gt;@task&lt;/tt&gt; decorator and will request the task to be executed
in the background twice (&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;add.delay(...)&lt;/span&gt;&lt;/tt&gt;). &lt;a class="footnote-reference" href="#id9" id="id3"&gt;[3]&lt;/a&gt; The results are then fetched
(&lt;tt class="docutils literal"&gt;asyncresult_1.get()&lt;/tt&gt;) and printed. Place this in a file named &lt;tt class="docutils literal"&gt;my_app.py&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="code python highlight literal-block"&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;celery&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Celery&lt;/span&gt;

&lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Celery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="s2"&gt;"my_app"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;backend&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"rpc://"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;broker&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"amqp://guest@localhost//"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;


&lt;span class="nd"&gt;@app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;


&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"__main__"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;# Request that the tasks run and capture their async results.&lt;/span&gt;
    &lt;span class="n"&gt;asyncresult_1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;asyncresult_2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;result_1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;asyncresult_1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;result_2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;asyncresult_2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="c1"&gt;# Should result in 3, 7.&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sa"&gt;f&lt;/span&gt;&lt;span class="s2"&gt;"Results: &lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;result_1&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;, &lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;result_2&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Usually you don’t care where (which worker) the task runs on it, or how it gets
there but sometimes you need! We can break down the components more to reveal more detail:&lt;/p&gt;
&lt;blockquote class="text-center"&gt;
&lt;a class="reference external image-reference" href="https://patrick.cloke.us/images/celery-architecture/celery-components.png"&gt;&lt;img alt="Celery components" src="https://patrick.cloke.us/images/celery-architecture/celery-components.png" style="width: 50%;"/&gt;&lt;/a&gt;
&lt;p&gt;The Celery components broken into sub-components.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="section" id="broker"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id18"&gt;Broker&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The message broker is a piece of off-the-shelf software which takes task requests
and queues them until a worker is ready to process them. Common options include
&lt;a class="reference external" href="https://www.rabbitmq.com/"&gt;RabbitMQ&lt;/a&gt;, or &lt;a class="reference external" href="https://redis.io"&gt;Redis&lt;/a&gt;, although your cloud provider might have a custom one.&lt;/p&gt;
&lt;p&gt;The broker may have some sub-components, including an exchange and one or more
queues. (Note that Celery tends to use &lt;span class="caps"&gt;AMQP&lt;/span&gt; terminology and sometimes emulates
features which do not exist on other brokers.)&lt;/p&gt;
&lt;p&gt;Configuring your broker is beyond the scope of this article (and depends heavily
on workload). The Celery &lt;a class="reference external" href="https://docs.celeryq.dev/en/v5.2.7/userguide/routing.html"&gt;routing documentation&lt;/a&gt; has more information on how and
why you might route tasks to different queues.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="workers"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id19"&gt;Workers&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Celery workers fetch queued tasks from the broker and then run the code defined in
your &lt;tt class="docutils literal"&gt;task&lt;/tt&gt;, they can optionally return a value via the results backend.&lt;/p&gt;
&lt;p&gt;Celery workers have a “consumer” which fetches tasks from the broker: by default
it requests many tasks at once, equivalent to “&lt;a class="reference external" href="https://docs.celeryq.dev/en/v5.2.7/userguide/configuration.html#std-setting-worker_prefetch_multiplier"&gt;prefetch multiplier&lt;/a&gt; x &lt;a class="reference external" href="https://docs.celeryq.dev/en/v5.2.7/userguide/configuration.html#std-setting-worker_concurrency"&gt;concurrency&lt;/a&gt;“.
(If your prefetch multiplier is 5 and your concurrency is 4, it attempts to
fetch up to 20 queued tasks from the broker.) Once fetched it places them into
an in-memory buffer. The task pool then runs each task via its &lt;tt class="docutils literal"&gt;Strategy&lt;/tt&gt; —
for a normal Celery &lt;tt class="docutils literal"&gt;Task&lt;/tt&gt; the task pool essentially executes tasks from the
consumer’s buffer.&lt;/p&gt;
&lt;p&gt;The worker also handles scheduling tasks to run in future (by queueing them
in-memory), but we will not go deeper into that here.&lt;/p&gt;
&lt;p&gt;Using the “prefork” pool, the consumer and task pool are separate processes, while
the “gevent”/”eventlet” pool uses coroutines, and the “threads” pool uses threads.
There’s also a “solo” pool which can be useful for testing (everything is run in
the same process: a single task runs at a time and blocks the consumer from
fetching more tasks.)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="backend"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id20"&gt;Backend&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The backend is another piece of off-the-shelf software which is used to store the
results of your task. It provides a key-value store and is commonly &lt;a class="reference external" href="https://redis.io"&gt;Redis&lt;/a&gt;,
although there are many options depending on how durable and large your results
are. The results backend can be queried by using the &lt;tt class="docutils literal"&gt;AsyncResult&lt;/tt&gt; object which
is returned to your application code. &lt;a class="footnote-reference" href="#id10" id="id4"&gt;[4]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Much like for brokers, how you configure results backends is beyond the scope of
this article.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="dataflow"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id21"&gt;Dataflow&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;You might have observed that the above components discussed at least several
different processes (client, broker, worker, worker pool, backend) which may also
exist on different computers. How does this all work to pass the task between
them? Usually this level of detail isn’t necessary to understand what it means
to “run a task in the background”, but it can be useful for diagnosing performance
or configuring brokers and backends.&lt;/p&gt;
&lt;p&gt;The main thing to understand is that there’s lots of serialization happening across
each process boundary:&lt;/p&gt;
&lt;blockquote class="text-center"&gt;
&lt;a class="reference external image-reference" href="https://patrick.cloke.us/images/celery-architecture/celery-dataflow.png"&gt;&lt;img alt="Celery dataflow" src="https://patrick.cloke.us/images/celery-architecture/celery-dataflow.png" style="width: 50%;"/&gt;&lt;/a&gt;
&lt;p&gt;A task message traversing from application code to the broker to a worker,
and a result traversing from a worker to a backend to application code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="section" id="request-serialization"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id22"&gt;Request Serialization&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;When a client requests for a task to be run the information needs to be passed to
the broker in a form it understands. The necessary data includes:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;The task identifier (e.g. &lt;tt class="docutils literal"&gt;my_app.add&lt;/tt&gt;).&lt;/li&gt;
&lt;li&gt;Any arguments (e.g. &lt;tt class="docutils literal"&gt;(1, 2)&lt;/tt&gt;) and keyword arguments.&lt;/li&gt;
&lt;li&gt;A request &lt;span class="caps"&gt;ID&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;Routing information.&lt;/li&gt;
&lt;li&gt;…and a bunch of other metadata.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Exactly what is included is defined by the &lt;a class="reference external" href="https://docs.celeryq.dev/en/v5.2.7/internals/protocol.html#message-protocol-task-v2"&gt;message protocol&lt;/a&gt; (of which Celery
has two, although they’re fairly similar).&lt;/p&gt;
&lt;p&gt;Most of the metadata gets placed in the headers while the task arguments, which
might be any Python class, need to be serialized into the body. Celery supports
&lt;a class="reference external" href="https://docs.celeryq.dev/en/v5.2.7/userguide/calling.html#calling-serializers"&gt;many serializers&lt;/a&gt; and uses &lt;a class="reference external" href="https://docs.python.org/3/library/json.html"&gt;&lt;span class="caps"&gt;JSON&lt;/span&gt;&lt;/a&gt; by default (&lt;a class="reference external" href="https://docs.python.org/dev/library/pickle.html#module-pickle"&gt;pickle&lt;/a&gt;, &lt;a class="reference external" href="http://yaml.org/"&gt;&lt;span class="caps"&gt;YAML&lt;/span&gt;&lt;/a&gt;, and &lt;a class="reference external" href="http://msgpack.org/"&gt;msgpack&lt;/a&gt;,
as well as custom schemes can be used as well).&lt;/p&gt;
&lt;p&gt;After serialization, Celery also supports &lt;a class="reference external" href="https://docs.celeryq.dev/en/v5.2.7/userguide/calling.html#compression"&gt;compressing the message&lt;/a&gt; or
&lt;a class="reference external" href="https://docs.celeryq.dev/en/v5.2.7/userguide/security.html#message-signing"&gt;signing the message&lt;/a&gt; for additional security.&lt;/p&gt;
&lt;p&gt;An example &lt;span class="caps"&gt;AMQP&lt;/span&gt; message containing the details of a task request (from RabbitMQ’s
&lt;a class="reference external" href="https://www.rabbitmq.com/management.html"&gt;management interface&lt;/a&gt;) is shown below:&lt;/p&gt;
&lt;blockquote class="text-center"&gt;
&lt;a class="reference external image-reference" href="https://patrick.cloke.us/images/celery-architecture/rabbitmq-task-message.png"&gt;&lt;img alt="Celery task wrapped in a RabbitMQ message" src="https://patrick.cloke.us/images/celery-architecture/rabbitmq-task-message.png" style="width: 50%;"/&gt;&lt;/a&gt;
&lt;p&gt;The example Celery task wrapped in a RabbitMQ message&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;When a worker fetches a task from the broker it deserializes it into a &lt;a class="reference external" href="https://docs.celeryq.dev/en/v5.2.7/userguide/tasks.html#task-request"&gt;Request&lt;/a&gt;
and executes it (as discussed above). In the case of a “prefork” worker pool the
&lt;tt class="docutils literal"&gt;Request&lt;/tt&gt; is serialized &lt;em&gt;again&lt;/em&gt; using pickle when passed to task pool &lt;a class="footnote-reference" href="#id11" id="id5"&gt;[5]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The worker pool then unpickles the request, loads the task code, and executes
it with the requested arguments. Finally your task code is running! Note that the
task code itself is not contained in the serialized request, that is loaded
separately by the worker.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="result-serialization"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id23"&gt;Result Serialization&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;When a task returns a value it gets stored in the results backend with enough
information for the original client to find it:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;The result &lt;span class="caps"&gt;ID&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;The result.&lt;/li&gt;
&lt;li&gt;…and some other metadata.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Similarly to tasks this information must be serialized before being placed in the
results backend (and gets split between the headers and body). Celery provides
configuration options to customize this serialization. &lt;a class="footnote-reference" href="#id12" id="id6"&gt;[6]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;An example &lt;span class="caps"&gt;AMQP&lt;/span&gt; message containing the details of a result is shown below:&lt;/p&gt;
&lt;blockquote class="text-center"&gt;
&lt;a class="reference external image-reference" href="https://patrick.cloke.us/images/celery-architecture/rabbitmq-result-message.png"&gt;&lt;img alt="Celery result wrapped in a RabbitMQ message" src="https://patrick.cloke.us/images/celery-architecture/rabbitmq-result-message.png" style="width: 50%;"/&gt;&lt;/a&gt;
&lt;p&gt;The example Celery result wrapped in a RabbitMQ message&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Once the result is fetched by the client it can deserialized the true (Python)
return value and provide it to the application code.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="final-thoughts"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id24"&gt;Final thoughts&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Since the Celery protocol is a public, documented &lt;span class="caps"&gt;API&lt;/span&gt; it allows you to create
task requests externally to Celery! As long as you can interface to the Celery broker
(and have some shared configuration) you can use a different application (or programming
language) to publish and/or consume tasks. This is exactly what others have done:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;JavaScript / TypeScript&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mher/node-celery"&gt;node-celery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/node-celery-ts/node-celery-ts"&gt;node-celery-ts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span class="caps"&gt;PHP&lt;/span&gt;:&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/gjedeer/celery-php"&gt;celery-php&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Rust&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/rusty-celery/rusty-celery"&gt;rusty-celery&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Go&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/gocelery/gocelery"&gt;gocelery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/marselester/gopher-celery"&gt;gopher-celery&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note that I haven’t used any of the above projects (and can’t vouch for them).&lt;/p&gt;
&lt;table class="docutils footnote" frame="void" id="id7" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"/&gt;&lt;col/&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Part of this started out as an &lt;a class="reference external" href="https://github.com/clokep/celery-batches/issues/69#issuecomment-1181855643"&gt;explanation of how celery-batches works&lt;/a&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id8" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"/&gt;&lt;col/&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;a class="reference external" href="https://docs.celeryq.dev/en/v5.2.7/userguide/periodic-tasks.html"&gt;Celery beat&lt;/a&gt; is another common component used to run scheduled or periodic
tasks. Architecture wise it takes the same place as your application code,
i.e. it runs forever and requests for tasks to be executed based on the time.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id9" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"/&gt;&lt;col/&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;There’s a &lt;a class="reference external" href="https://docs.celeryq.dev/en/v5.2.7/userguide/calling.html"&gt;bunch of ways&lt;/a&gt; to do this, &lt;tt class="docutils literal"&gt;apply_async&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;delay&lt;/tt&gt; are the
most common, but don’t impact the contents of this article.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id10" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"/&gt;&lt;col/&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;As a quick aside — &lt;tt class="docutils literal"&gt;AsyncResult&lt;/tt&gt; does not refer to async/await in Python.
&lt;tt class="docutils literal"&gt;AsyncResult.get()&lt;/tt&gt; is &lt;strong&gt;synchronous&lt;/strong&gt;. A &lt;a class="reference external" href="https://patrick.cloke.us/posts/2018/10/23/calling-celery-from-twisted/"&gt;previous article&lt;/a&gt; has some more
information on this.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id11" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"/&gt;&lt;col/&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id5"&gt;[5]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;This is not configurable. The Celery &lt;a class="reference external" href="https://docs.celeryq.dev/en/v5.2.7/userguide/security.html#serializers"&gt;security guide&lt;/a&gt; recommends not using
pickle for serializers (and it is &lt;a class="reference external" href="https://docs.python.org/dev/library/pickle.html"&gt;well known&lt;/a&gt; that pickle can be a security
flaw), but it does not seem documented anywhere that pickle will be used with
the prefork pool. If you are using &lt;span class="caps"&gt;JSON&lt;/span&gt; to initially serialize to the broker
then your task should only be left with “simple” types (strings, integers,
floats, null, lists, and dictionaries) so this should not be an issue.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id12" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"/&gt;&lt;col/&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id6"&gt;[6]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Tasks and results can be configured to have different serializers (or different
compression settings) via the &lt;tt class="docutils literal"&gt;task_&lt;/tt&gt; vs. &lt;tt class="docutils literal"&gt;result_&lt;/tt&gt; configuration options.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Patrick Cloke</dc:creator><pubDate>Fri, 15 Sep 2023 15:28:00 -0400</pubDate><guid isPermaLink="false">tag:patrick.cloke.us,2023-09-15:/posts/2023/09/15/celery-architecture-breakdown/</guid><category>articles</category><category>celery</category></item><item><title>celery-batches 0.5 released!</title><link>https://patrick.cloke.us/posts/2021/05/24/celery-batches-0.5-released/</link><description>&lt;p&gt;A &lt;a class="reference external" href="https://pypi.org/project/celery-batches/0.5/"&gt;new version (v0.5)&lt;/a&gt; of &lt;a class="reference external" href="https://github.com/clokep/celery-batches/"&gt;celery-batches&lt;/a&gt; is available which adds support for
Celery 5.1 and fixes storing of results when using the &lt;a class="reference external" href="https://docs.celeryproject.org/en/v5.1.0/userguide/tasks.html#rpc-result-backend-rabbitmq-qpid"&gt;&lt;span class="caps"&gt;RPC&lt;/span&gt; result backend&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;As &lt;a class="reference external" href="https://patrick.cloke.us/posts/2019/10/04/celery-amqp-backends/"&gt;explored previously&lt;/a&gt;, the &lt;span class="caps"&gt;RPC&lt;/span&gt; result backend works by having a results queue
per client, unfortunately celery-batches was attempting to store the results in
a queue named after the task &lt;span class="caps"&gt;ID&lt;/span&gt; instead of the client &lt;span class="caps"&gt;ID&lt;/span&gt; (Celery internally calls
this the &amp;#8220;correlation &lt;span class="caps"&gt;ID&lt;/span&gt;&amp;#8221;) &lt;a class="footnote-reference" href="#id2" id="id1"&gt;[1]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This unfortunately requires a change to client code to pass the batched request
into the &lt;tt class="docutils literal"&gt;mark_as_done&lt;/tt&gt; method, using the example &lt;a class="reference external" href="https://celery-batches.readthedocs.io/en/v0.5/"&gt;from the documnation&lt;/a&gt; with
the changed line&amp;nbsp;highlighted:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;requests&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;urlparse&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;urlparse&lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;celery_batches&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Batches&lt;/span&gt;

&lt;span class="n"&gt;wot_api_target&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;https://api.mywot.com/0.4/public_link_json&amp;#39;&lt;/span&gt;

&lt;span class="nd"&gt;@app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;base&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;Batches&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;flush_every&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;flush_interval&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;wot_api&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;requests&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;sig&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt;
    &lt;span class="n"&gt;responses&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wot_api_real&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sig&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;request&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;requests&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c1"&gt;# use mark_as_done to manually return response data&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;request&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;zip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;responses&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;requests&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="hll"&gt;        &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;backend&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mark_as_done&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;wot_api_real&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;urls&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;domains&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;urlparse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;netloc&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;urls&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;requests&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;wot_api_target&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;hosts&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;domains&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;json&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;domain&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;domain&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;domains&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;table class="docutils footnote" frame="void" id="id2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;The &lt;span class="caps"&gt;RPC&lt;/span&gt; backend has &lt;a class="reference external" href="https://github.com/celery/celery/blob/v5.1.0/celery/backends/rpc.py#L166"&gt;code which pulls out the correlation &lt;span class="caps"&gt;ID&lt;/span&gt;&lt;/a&gt;, but falls
back to the task &lt;span class="caps"&gt;ID&lt;/span&gt; if not given. This is called via an
&lt;a class="reference external" href="https://github.com/celery/celery/blob/v5.1.0/celery/backends/rpc.py#L198-L200"&gt;override of the &lt;tt class="docutils literal"&gt;store_result&lt;/tt&gt; method&lt;/a&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Patrick Cloke</dc:creator><pubDate>Mon, 24 May 2021 16:56:00 -0400</pubDate><guid isPermaLink="false">tag:patrick.cloke.us,2021-05-24:/posts/2021/05/24/celery-batches-0.5-released/</guid><category>articles</category><category>celery</category><category>celery-batches</category></item><item><title>celery-batches 0.4 released!</title><link>https://patrick.cloke.us/posts/2020/11/30/celery-batches-0.4-released/</link><description>&lt;p&gt;Earlier today I released a version &lt;a class="reference external" href="https://pypi.org/project/celery-batches/0.4/"&gt;0.4&lt;/a&gt; of &lt;a class="reference external" href="https://github.com/clokep/celery-batches/"&gt;celery-batches&lt;/a&gt; with support for
Celery 5.0. As part of this release support for Python &amp;lt; 3.6 was dropped and
support for Celery &amp;lt; 4.4 was&amp;nbsp;dropped.&lt;/p&gt;
&lt;p&gt;celery-batches is a small library that allows you process multiple calls to a
&lt;a class="reference external" href="https://github.com/celery/celery/"&gt;Celery&lt;/a&gt; task together. The batches can be processed based on a count of task
calls or a timer. It started as an update of the &lt;tt class="docutils literal"&gt;celery.contrib.batches&lt;/tt&gt;
code to support Celery 4.0+ and has grown to support some additional&amp;nbsp;features.&lt;/p&gt;
&lt;p&gt;The project was also transferred on GitHub to my personal namespace (from my
previous employer). Realistically it was maintained by me already and this is
just a formality. As part of this release the &lt;a class="reference external" href="https://celery-batches.readthedocs.io/en/v0.4/"&gt;documentation&lt;/a&gt; is now available
on Read the&amp;nbsp;Docs.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Patrick Cloke</dc:creator><pubDate>Mon, 30 Nov 2020 16:50:00 -0500</pubDate><guid isPermaLink="false">tag:patrick.cloke.us,2020-11-30:/posts/2020/11/30/celery-batches-0.4-released/</guid><category>articles</category><category>celery</category><category>celery-batches</category></item><item><title>Celery AMQP Backends</title><link>https://patrick.cloke.us/posts/2019/10/04/celery-amqp-backends/</link><description>&lt;div class="admonition note"&gt;
&lt;p class="first admonition-title"&gt;Note&lt;/p&gt;
&lt;p class="last"&gt;This started as notes explaining the internals of how Celery&amp;#8217;s &lt;span class="caps"&gt;AMQP&lt;/span&gt; backends
operate. This isn&amp;#8217;t meant to be a comparison or prove one is better or that
one is broken. There just seemed to be a lack of documentation about the
design and limitations of each&amp;nbsp;backend.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Celery comes with &lt;a class="reference external" href="https://docs.celeryproject.org/en/latest/userguide/configuration.html#task-result-backend-settings"&gt;many results backends&lt;/a&gt;, two of which use &lt;span class="caps"&gt;AMQP&lt;/span&gt; under the
hood: the &amp;#8220;&lt;span class="caps"&gt;AMQP&lt;/span&gt;&amp;#8221; and &amp;#8220;&lt;span class="caps"&gt;RPC&lt;/span&gt;&amp;#8221; backends. Both of them publish results as messages
into &lt;span class="caps"&gt;AMQP&lt;/span&gt; queues. They&amp;#8217;re convenient since you only need one piece of
infrastructure to handle both tasks and results (e.g. &lt;a class="reference external" href="https://www.rabbitmq.com/"&gt;RabbitMQ&lt;/a&gt;). Check the
&lt;a class="reference external" href="https://docs.celeryproject.org/en/latest/userguide/configuration.html#result-backend"&gt;&lt;tt class="docutils literal"&gt;result_backend&lt;/tt&gt;&lt;/a&gt; setting if you&amp;#8217;re unsure what you&amp;#8217;re&amp;nbsp;using!&lt;/p&gt;
&lt;div class="section" id="amqp-backend"&gt;
&lt;h2&gt;&lt;span class="caps"&gt;AMQP&lt;/span&gt;&amp;nbsp;backend&lt;/h2&gt;
&lt;p&gt;The &lt;a class="reference external" href="https://docs.celeryproject.org/en/latest/internals/reference/celery.backends.amqp.html"&gt;&lt;span class="caps"&gt;AMQP&lt;/span&gt; backend&lt;/a&gt; is deprecated, it uses a results queue &lt;strong&gt;per task call&lt;/strong&gt;,
this doesn&amp;#8217;t scale well since there is significant overhead (many queues, many
bindings, etc.). That&amp;#8217;s pretty much all I know about it, I&amp;#8217;ve never used&amp;nbsp;it.&lt;/p&gt;
&lt;p&gt;A system level view is&amp;nbsp;below:&lt;/p&gt;
&lt;blockquote class="text-center"&gt;
&lt;a class="reference external image-reference" href="https://patrick.cloke.us/images/celery-amqp-backends/amqp-backend.png"&gt;&lt;img alt="RPC requeueing behavior" src="https://patrick.cloke.us/images/celery-amqp-backends/amqp-backend.png" style="width: 80%;" /&gt;&lt;/a&gt;
&lt;/blockquote&gt;
&lt;p&gt;The caller produces a task into the task queue. The worker consumes the task
from this queue and creates a result, which is added to a separate results queue
per task call. In the example above there&amp;#8217;s tasks A, B, C, etc. Each of those
produces a result (A&amp;#8217;, B&amp;#8217;, C&amp;#8217;, etc.) in separate&amp;nbsp;queues.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="rpc-backend"&gt;
&lt;h2&gt;&lt;span class="caps"&gt;RPC&lt;/span&gt;&amp;nbsp;backend&lt;/h2&gt;
&lt;p&gt;The &lt;a class="reference external" href="https://docs.celeryproject.org/en/latest/internals/reference/celery.backends.rpc.html"&gt;&lt;span class="caps"&gt;RPC&lt;/span&gt; backend&lt;/a&gt; uses a results queue &lt;strong&gt;per client&lt;/strong&gt; which scales better, but
is a bit more limited in functionality &amp;#8212; it assumes that the process that
produces the task also consumes the result (hence the &amp;#8220;&lt;span class="caps"&gt;RPC&lt;/span&gt;&amp;#8221; name &amp;#8212; referring to
&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Remote_procedure_call"&gt;remote procedure call&lt;/a&gt;). See the &lt;a class="reference external" href="https://docs.celeryproject.org/en/latest/history/whatsnew-3.1.html#new-rpc-result-backend"&gt;announcement of the &lt;span class="caps"&gt;RPC&lt;/span&gt; backend&lt;/a&gt; for more&amp;nbsp;information.&lt;/p&gt;
&lt;p&gt;A system level view is&amp;nbsp;below:&lt;/p&gt;
&lt;blockquote class="text-center"&gt;
&lt;a class="reference external image-reference" href="https://patrick.cloke.us/images/celery-amqp-backends/rpc-backend.png"&gt;&lt;img alt="RPC requeueing behavior" src="https://patrick.cloke.us/images/celery-amqp-backends/rpc-backend.png" style="width: 80%;" /&gt;&lt;/a&gt;
&lt;/blockquote&gt;
&lt;p&gt;The caller produces a task into the task queue. The worker consumes the task
from this queue and creates a result, which is added to a results queue per
caller. In the example above there&amp;#8217;s tasks A, B, C, etc. Each of those
produces a result (A&amp;#8217;, B&amp;#8217;, C&amp;#8217;, etc.) in the same&amp;nbsp;queue.&lt;/p&gt;
&lt;p&gt;Since the results go into a queue per caller, this works well when the caller
(and only the caller) is what needs to consume the&amp;nbsp;result.&lt;/p&gt;
&lt;p&gt;Other things to note with the &lt;span class="caps"&gt;RPC&lt;/span&gt;&amp;nbsp;backend:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Each result can only be consumed once (since it is then removed from the
results&amp;nbsp;queue).&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://docs.celeryproject.org/en/latest/userguide/canvas.html#chords"&gt;chords&lt;/a&gt; are not supported (but that is not something that I&amp;#8217;ve ever&amp;nbsp;used).&lt;/li&gt;
&lt;li&gt;Results are discarded when the client disconnects or if the broker restarts
(they&amp;#8217;re not&amp;nbsp;durable).&lt;/li&gt;
&lt;li&gt;If there is too much &amp;#8220;state history&amp;#8221; (if the results queue grows too large), a
&lt;a class="reference external" href="https://docs.celeryproject.org/en/latest/internals/reference/celery.backends.rpc.html#celery.backends.rpc.BacklogLimitExceeded"&gt;&lt;tt class="docutils literal"&gt;BacklogLimitExceeded&lt;/tt&gt;&lt;/a&gt; exception will be raised. (By default too large is
1000 pending task&amp;nbsp;results.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The &lt;span class="caps"&gt;RPC&lt;/span&gt; backend can run into issues with &lt;span class="caps"&gt;AMQP&lt;/span&gt; queues being &lt;a class="reference external" href="https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)"&gt;&lt;span class="caps"&gt;FIFO&lt;/span&gt;&lt;/a&gt; &amp;#8212; if two
tasks (A &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; B) are started and task B finishes before A, but the client tries to
get the result of task A first&amp;#8230;what happens? The &lt;span class="caps"&gt;RPC&lt;/span&gt; backend does one of two&amp;nbsp;things:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Requeues it (the&amp;nbsp;default).&lt;/li&gt;
&lt;li&gt;Caches it locally until it is&amp;nbsp;needed.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The requeuing behavior is shown&amp;nbsp;below:&lt;/p&gt;
&lt;blockquote class="text-center"&gt;
&lt;a class="reference external image-reference" href="https://patrick.cloke.us/images/celery-amqp-backends/rpc-requeues.png"&gt;&lt;img alt="RPC requeueing behavior" src="https://patrick.cloke.us/images/celery-amqp-backends/rpc-requeues.png" style="width: 50%;" /&gt;&lt;/a&gt;
&lt;/blockquote&gt;
&lt;p&gt;In the example above, result B was added into the queue before A, but A is
needed first. The queue is run down until A is received and all other items are
requeued (onto the back of the&amp;nbsp;queue).&lt;/p&gt;
&lt;p&gt;If you have many parallel tasks running this can cause issues, either by running
into the &lt;tt class="docutils literal"&gt;BacklogLimitExceeded&lt;/tt&gt; error or just lots of churn in the queue
(meaning lots of&amp;nbsp;I/O).&lt;/p&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Patrick Cloke</dc:creator><pubDate>Fri, 04 Oct 2019 08:10:00 -0400</pubDate><guid isPermaLink="false">tag:patrick.cloke.us,2019-10-04:/posts/2019/10/04/celery-amqp-backends/</guid><category>articles</category><category>celery</category></item><item><title>Celery without a Results Backend</title><link>https://patrick.cloke.us/posts/2019/07/17/celery-without-a-results-backend/</link><description>&lt;p&gt;The &lt;a class="reference external" href="http://www.celeryproject.org/"&gt;Celery&lt;/a&gt; &lt;a class="reference external" href="https://docs.celeryproject.org/en/latest/reference/celery.html#celery.Celery.send_task"&gt;&lt;tt class="docutils literal"&gt;send_task&lt;/tt&gt;&lt;/a&gt; method allows you to invoke a task by name without
importing it. &lt;a class="footnote-reference" href="#id5" id="id1"&gt;[1]&lt;/a&gt; There is an undocumented &lt;a class="footnote-reference" href="#id6" id="id2"&gt;[2]&lt;/a&gt; caveat to using &lt;tt class="docutils literal"&gt;send_task&lt;/tt&gt;:
it doesn&amp;#8217;t have access to the configuration of the task (from when the task was
created using the &lt;a class="reference external" href="https://docs.celeryproject.org/en/latest/reference/celery.html#celery.Celery.task"&gt;&lt;tt class="docutils literal"&gt;&amp;#64;task&lt;/tt&gt; decorator&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Much of this configuration doesn&amp;#8217;t matter to the caller, for example the caller
doesn&amp;#8217;t care&amp;nbsp;about:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Whether the task is bound or&amp;nbsp;not.&lt;/li&gt;
&lt;li&gt;The retry configuration of&amp;nbsp;tasks.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There is also configuration from the caller that &lt;em&gt;must&lt;/em&gt; be right for the task to
execute as you&amp;#8217;d&amp;nbsp;expect:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;The number of arguments and the keywords for any keyword&amp;nbsp;arguments.&lt;/li&gt;
&lt;li&gt;The serializer or compressor must match what the worker can&amp;nbsp;handle.&lt;/li&gt;
&lt;li&gt;If a non-default results backend is to be&amp;nbsp;used.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Another piece of configuration that matters (which surprised me and had a
performance impact for us &lt;a class="footnote-reference" href="#id7" id="id3"&gt;[3]&lt;/a&gt;) is whether to ignore a task result or not.
Unexpectedly, Celery will attempt to connect to the results backend &lt;em&gt;on task call&lt;/em&gt;.
I assumed that the results backend would never be contacted since we never
attempted to &lt;strong&gt;retrieve&lt;/strong&gt; a result! This turned out to be&amp;nbsp;untrue.&lt;/p&gt;
&lt;p&gt;Once identified, The fix was straightforward! We ensured that every task which
had &lt;tt class="docutils literal"&gt;ignore_result=True&lt;/tt&gt; on task declaration also had &lt;tt class="docutils literal"&gt;ignore_result=True&lt;/tt&gt;
on task call (when using &lt;tt class="docutils literal"&gt;send_task&lt;/tt&gt;). &lt;a class="footnote-reference" href="#id8" id="id4"&gt;[4]&lt;/a&gt; This duplciation is unfortunate,
but easy&amp;nbsp;enough.&lt;/p&gt;
&lt;p&gt;We figured this out due to a calling process which doesn&amp;#8217;t use any results, but
the &lt;tt class="docutils literal"&gt;celery.backends&lt;/tt&gt; module was appearing in the &lt;a class="reference external" href="https://pyflame.readthedocs.io"&gt;pyflame&lt;/a&gt; profiles.
Another solution (for this particular setup) was to use the (&lt;a class="reference external" href="http://docs.celeryproject.org/en/latest/userguide/configuration.html#task-result-backend-settings"&gt;undocumented&lt;/a&gt;)
&lt;tt class="docutils literal"&gt;disabled&lt;/tt&gt; results&amp;nbsp;backend.&lt;/p&gt;
&lt;table class="docutils footnote" frame="void" id="id5" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;There are a variety of reasons you might want to do this, but I&amp;#8217;ve
used it when tasks that use &lt;a class="reference external" href="https://www.djangoproject.com/"&gt;Django&lt;/a&gt; models but the calling process
does not have Django configured.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id6" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;I couldn&amp;#8217;t find any documentation about it at least. Maybe this is meant
to be obvious, but it didn&amp;#8217;t click for me without deep understanding of
how Celery works.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id7" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;The performance impact we were seeing was due to the &lt;span class="caps"&gt;TCP&lt;/span&gt; negotiation and
login to the results backend. This got especially bad if the results
backend was under load or down.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id8" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Note that it is a &lt;a class="reference external" href="https://docs.celeryproject.org/en/latest/userguide/tasks.html?highlight=argsrepr#ignore-results-you-don-t-want"&gt;best practice&lt;/a&gt; to ignore results on tasks where you
don&amp;#8217;t need the result!&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Patrick Cloke</dc:creator><pubDate>Wed, 17 Jul 2019 20:35:00 -0400</pubDate><guid isPermaLink="false">tag:patrick.cloke.us,2019-07-17:/posts/2019/07/17/celery-without-a-results-backend/</guid><category>articles</category><category>celery</category></item><item><title>Calling Celery from Twisted</title><link>https://patrick.cloke.us/posts/2018/10/23/calling-celery-from-twisted/</link><description>
&lt;div class="section" id="background"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id13"&gt;Background&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I use &lt;a class="reference external" href="https://twistedmatrix.com/"&gt;Twisted&lt;/a&gt; and &lt;a class="reference external" href="http://www.celeryproject.org/"&gt;Celery&lt;/a&gt; daily at work, both are useful frameworks, both have
a lot of great information out there, but a particular use (that I haven’t seen
discussed much online, hence this post) is calling Celery tasks &lt;em&gt;from&lt;/em&gt; Twisted
(and subsequently using the result).&lt;/p&gt;
&lt;p&gt;The difference between Twisted and Celery seems to be a frequent question people
have (check out the number of questions on &lt;a class="reference external" href="https://stackoverflow.com/search?q=twisted+or+celery"&gt;StackOverflow&lt;/a&gt;). The main difference,
from my point of view, is that Twisted is a “batteries included” networking
framework that is asynchronous / evented for handling of I/O, Celery is a &lt;em&gt;distributed&lt;/em&gt;
task queue which excels at short &lt;span class="caps"&gt;CPU&lt;/span&gt;-bound tasks where the asynchronous nature
comes from running multiple processes. The &lt;a class="reference external" href="https://github.com/SentimensRG/txCelery"&gt;txCelery&lt;/a&gt; project has a nice summary
on their page:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Celery is an outstanding choice for dispatching &lt;em&gt;short-lived&lt;/em&gt;,
computationally-expensive tasks to a distributed backend system. Note the
emphasis; Celery is ill-suited for tasks tasks that require updating some
in-memory representation with out-of-process data. If you want a specific
process to read data from standard input, for instance, good luck…&lt;/p&gt;
&lt;p&gt;Twisted can be though of as having the opposite problem. Twisted is very
good at maintaining and updating in-memory representations over extended
periods of time, but fails miserably at performing expensive computations.
Twisted notably has no built-in constructs for managing distributed task queues.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The two main ways to interact with Celery are:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Call a task (and have it happen asynchronously).&lt;/li&gt;
&lt;li&gt;Get the result of that task.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In order to call Celery from Twisted we’ll need to ensure that both of these can
happen in a way that matches Twisted’s execution model. This might be
illustrated best by a code example, we would want to do something like the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;celery&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Celery&lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;twisted.internet&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;defer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;task&lt;/span&gt;

&lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Celery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;broker&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'amqp://guest:guest@127.0.0.1:5672//'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;backend&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'rpc'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nd"&gt;@app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;my_task&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c1"&gt;# Normally you'd do a CPU bound task here.&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;

&lt;span class="nd"&gt;@defer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;inlineCallbacks&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="c1"&gt;# Normally you'd open some listening sockets or some outbound&lt;/span&gt;
    &lt;span class="c1"&gt;# connections here.&lt;/span&gt;

    &lt;span class="c1"&gt;# Call into Celery!&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;my_task&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c1"&gt;# Should print '1 + 2 = 3'.&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s2"&gt; + &lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s2"&gt; = &lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;react&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="initial-approach"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id14"&gt;Initial Approach&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The initial attempt to pair these libraries is to call Celery tasks like you
would normally (import the Celery task and call &lt;a class="reference external" href="http://docs.celeryproject.org/en/latest/reference/celery.app.task.html#celery.app.task.Task.delay"&gt;&lt;tt class="docutils literal"&gt;delay()&lt;/tt&gt;&lt;/a&gt; on it). &lt;a class="footnote-reference" href="#id7" id="id1"&gt;[1]&lt;/a&gt; There’s
a hint that this won’t work in &lt;a class="reference external" href="http://docs.celeryproject.org/en/latest/reference/celery.app.task.html#celery.app.task.Task.delay"&gt;the documentation&lt;/a&gt; however:&lt;/p&gt;
&lt;blockquote&gt;
Apply tasks asynchronously by sending a message.&lt;/blockquote&gt;
&lt;p&gt;The documentation around calling &lt;a class="reference external" href="http://docs.celeryproject.org/en/latest/reference/celery.result.html#celery.result.AsyncResult.get"&gt;&lt;tt class="docutils literal"&gt;AsyncResult.get()&lt;/tt&gt;&lt;/a&gt;, to retrieve the result
also hints about issues:&lt;/p&gt;
&lt;blockquote&gt;
Wait until task is ready, and return its result.&lt;/blockquote&gt;
&lt;p&gt;It isn’t incredibly clear from the documentation, but this points to two
separate issues with calling Celery from Twisted:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;In both of these situations, (synchronous) I/O is happening in the
background when you make this call! &lt;a class="footnote-reference" href="#id8" id="id2"&gt;[2]&lt;/a&gt; I/O happening outside of the
reactor is a big no-no in a Twisted process since it can block the reactor
from running. &lt;a class="footnote-reference" href="#id9" id="id3"&gt;[3]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Additionally, the &lt;tt class="docutils literal"&gt;AsyncResult.get()&lt;/tt&gt; call blocks until a result is ready,
this doesn’t fit well into an evented programming paradigm. &lt;a class="footnote-reference" href="#id10" id="id4"&gt;[4]&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The second problem is handled well by the &lt;a class="reference external" href="https://github.com/SentimensRG/txCelery"&gt;txCelery&lt;/a&gt; package, it allows you to
call a task and get a sub-class of &lt;a class="reference external" href="http://twistedmatrix.com/documents/current/api/twisted.internet.defer.Deferred.html"&gt;&lt;tt class="docutils literal"&gt;Deferred&lt;/tt&gt;&lt;/a&gt; which resolves into the result
of the task call by periodically monitoring the status of the result.&lt;/p&gt;
&lt;p&gt;Unfortunately txCelery doesn’t solve the first issue (to my knowledge) since it
just uses the normal mechanisms built into Celery for I/O (which causes I/O in
the reactor thread).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="threaded-approach"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id15"&gt;Threaded Approach&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Twisted has a thread pool and makes it super easy to ask it to “run this code in
a non-reactor thread and return the result to me”. It is pretty straightforward
to cobble together a way to use &lt;a class="reference external" href="https://twistedmatrix.com/documents/current/api/twisted.internet.threads.html#deferToThread"&gt;&lt;tt class="docutils literal"&gt;threads.deferToThread()&lt;/tt&gt;&lt;/a&gt; to call
&lt;a class="reference external" href="http://docs.celeryproject.org/en/latest/reference/celery.html#celery.Celery.send_task"&gt;&lt;tt class="docutils literal"&gt;Celery.send_task()&lt;/tt&gt;&lt;/a&gt; &lt;a class="footnote-reference" href="#id11" id="id5"&gt;[5]&lt;/a&gt;. You still need an asynchronous way to check if the
task result is ready, however. You could just call &lt;tt class="docutils literal"&gt;AsyncResult.get()&lt;/tt&gt; in a
thread, but you will likely quickly exhaust your thread pool since that blocks
until a result is ready. Alternately you can check the status of a task using
the &lt;a class="reference external" href="http://docs.celeryproject.org/en/latest/reference/celery.result.html#celery.result.AsyncResult.state"&gt;&lt;tt class="docutils literal"&gt;state&lt;/tt&gt;&lt;/a&gt; property of an &lt;tt class="docutils literal"&gt;AsyncResult&lt;/tt&gt;. (I found it very surprising that
accessing a &lt;em&gt;property&lt;/em&gt; of this object causes I/O to happen, but it does.)&lt;/p&gt;
&lt;p&gt;Connecting these ideas together we came up with something similar to the
following (note that this is heavily inspired by what txCelery does, but pushes
all I/O onto a separate thread instead of doing it in the reactor thread):&lt;/p&gt;
&lt;pre class="code python highlight literal-block"&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;celery&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;states&lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;twisted.internet&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;defer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;reactor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;threads&lt;/span&gt;


&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;send_task&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c1"&gt;# Call the real function via a background thread.&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;threads&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;deferToThread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send_task&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;addCallback&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CeleryDeferred&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;CeleryDeferred&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;defer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Deferred&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;"""
    Extension of the Twisted Deferred object that wraps a Celery AsyncResult.

    This Deferred will occasionally poll the Celery task for its status. When
    complete, the Deferred will resolve and any added callbacks will be run.

    Inspired by txCelery: https://github.com/SentimensRG/txCelery/
    """&lt;/span&gt;
    &lt;span class="n"&gt;CHECK_INTERVAL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.25&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;async_result&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="c1"&gt;# Deferred is an old-style class&lt;/span&gt;
        &lt;span class="n"&gt;defer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Deferred&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_canceller&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;async_result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;async_result&lt;/span&gt;
        &lt;span class="c1"&gt;# Start the monitor loop&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;check_state&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;check_state&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;"""Check the status of the celery task on another thread."""&lt;/span&gt;
        &lt;span class="n"&gt;threads&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;deferToThread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_state&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;addCallbacks&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state_received&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;errback&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;get_state&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;"""Check the status of the celery task directly"""&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;async_result&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;state_received&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;celery_state&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;"""Called when the check_state thread finishes"""&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;celery_state&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;states&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;UNREADY_STATES&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="c1"&gt;# Schedule another status check, to be run later.&lt;/span&gt;
            &lt;span class="n"&gt;reactor&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;callLater&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CHECK_INTERVAL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;check_state&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;celery_state&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;states&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SUCCESS&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;callback&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;async_result&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;celery_state&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;states&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FAILURE&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="c1"&gt;# This will contain the Exception instance if the task raised one&lt;/span&gt;
            &lt;span class="c1"&gt;# http://docs.celeryproject.org/en/latest/reference/celery.result.html&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;errback&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;async_result&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;celery_state&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;states&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;REVOKED&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;errback&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;defer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CancelledError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Task &lt;/span&gt;&lt;span class="si"&gt;{0}&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;async_result&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="c1"&gt;# An unknown state was returned.&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;errback&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ne"&gt;ValueError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Unknown state: `&lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s1"&gt;`'&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;celery_state&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;_canceller&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="c1"&gt;# Revoke the celery task&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;async_result&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;revoke&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;The calling syntax of this isn’t as nice as the initial approach, but it is
pretty close (the modified lines are highlighted):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;celery&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Celery&lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;twisted.internet&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;defer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;task&lt;/span&gt;
&lt;span class="hll"&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;twistedcelery&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;send_task&lt;/span&gt;
&lt;/span&gt;
&lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Celery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;broker&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'amqp://guest:guest@127.0.0.1:5672//'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;backend&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'rpc'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nd"&gt;@app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;my_task&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c1"&gt;# Normally you'd do a CPU bound task here.&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;

&lt;span class="nd"&gt;@defer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;inlineCallbacks&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="c1"&gt;# Normally you'd open some listening sockets or some outbound&lt;/span&gt;
    &lt;span class="c1"&gt;# connections here.&lt;/span&gt;

    &lt;span class="c1"&gt;# Call into Celery!&lt;/span&gt;
&lt;span class="hll"&gt;    &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;send_task&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'my_task'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/span&gt;    &lt;span class="c1"&gt;# Should print '1 + 2 = 3'.&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s2"&gt; + &lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s2"&gt; = &lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;react&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="twisted-native-approach"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id16"&gt;Twisted-native Approach&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I think the above solutions are fundamentally wrong, but are easy-ish to
implement. They might work &lt;span class="caps"&gt;OK&lt;/span&gt; for small loads, or if increased latency is
acceptable, but will start to fail when a large number of pending tasks are
necessary. A better way is to consider:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Celery is designed to be &lt;a class="reference external" href="http://docs.celeryproject.org/en/latest/faq.html#is-celery-dependent-on-pickle"&gt;language&lt;/a&gt; &lt;a class="reference external" href="http://docs.celeryproject.org/en/latest/faq.html#is-celery-multilingual"&gt;independent&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Celery &lt;a class="reference external" href="http://docs.celeryproject.org/en/latest/internals/protocol.html"&gt;message formats&lt;/a&gt; are part of the public “&lt;span class="caps"&gt;API&lt;/span&gt;”. &lt;a class="footnote-reference" href="#id12" id="id6"&gt;[6]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Celery uses standard networking protocols to enable distributed processing.&lt;/li&gt;
&lt;li&gt;Twisted is designed to efficiency implement networking protocols.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This lead me to the conclusion that Twisted can just treat Celery tasks as if it
is implemented in a different language and just try to directly communicate with
the Celery broker and backend. It can just send task calls and query for
responses, when available. We can be a little bit more clever, however, and use
Celery to process the details of the messages to send, the queue to send them
to, etc.&lt;/p&gt;
&lt;p&gt;The hope is to end up with code like this (again, modified lines are highlighted):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;celery&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Celery&lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;twisted.internet&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;defer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;task&lt;/span&gt;
&lt;span class="hll"&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;twistedcelery&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;TwistedCelery&lt;/span&gt;
&lt;/span&gt;
&lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Celery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;broker&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'amqp://guest:guest@127.0.0.1:5672//'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;backend&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'rpc'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nd"&gt;@app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;my_task&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c1"&gt;# Normally you'd do a CPU bound task here.&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;

&lt;span class="nd"&gt;@defer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;inlineCallbacks&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="c1"&gt;# Normally you'd open some listening sockets or some outbound&lt;/span&gt;
    &lt;span class="c1"&gt;# connections here.&lt;/span&gt;

&lt;span class="hll"&gt;    &lt;span class="c1"&gt;# Turn the Celery app into a TwistedCelery app, which uses Twisted to do&lt;/span&gt;
&lt;/span&gt;&lt;span class="hll"&gt;    &lt;span class="c1"&gt;# I/O under the hood.&lt;/span&gt;
&lt;/span&gt;&lt;span class="hll"&gt;    &lt;span class="n"&gt;tx_app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TwistedCelery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;
    &lt;span class="c1"&gt;# Call into Celery!&lt;/span&gt;
&lt;span class="hll"&gt;    &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;tx_app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send_task&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'my_task'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/span&gt;    &lt;span class="c1"&gt;# Should print '1 + 2 = 3'.&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s2"&gt; + &lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s2"&gt; = &lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;react&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I’ve started the &lt;a class="reference external" href="https://github.com/clokep/twistedcelery"&gt;Twisted-Celery&lt;/a&gt; project in order to accomplish this goal. It
uses Celery to create the messages and to decide what exchange/queue/etc. to
use, but allows Twisted to handle all communication to your configured Celery
broker and backend. It exposes a &lt;tt class="docutils literal"&gt;send_task()&lt;/tt&gt; compatible &lt;span class="caps"&gt;API&lt;/span&gt;, but returns a
&lt;tt class="docutils literal"&gt;Deferred&lt;/tt&gt; instead of an &lt;tt class="docutils literal"&gt;AsyncResult&lt;/tt&gt; so you can write Twisted-compatible
code easily.&lt;/p&gt;
&lt;p&gt;It is just a proof of concept right now, but was successfully tested on a real
project. Note that it currently only supports &lt;span class="caps"&gt;AMQP&lt;/span&gt;, but this should be
expandable to other brokers. I won’t go into the details of how it works here,
but the hope is that you can give it a configured Celery app and it “just works”
with Twisted.&lt;/p&gt;
&lt;p&gt;If you’re interested in helping out, checkout the &lt;a class="reference external" href="https://github.com/clokep/twistedcelery"&gt;GitHub repository&lt;/a&gt; or leave a
comment below.&lt;/p&gt;
&lt;table class="docutils footnote" frame="void" id="id7" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"/&gt;&lt;col/&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;If you’re unfamiliar with Celery, briefly it allows a “task” is defined
in Python code, a “worker” is used to execute those tasks. The code
which wants to execute those tasks calls &lt;tt class="docutils literal"&gt;delay()&lt;/tt&gt; or
&lt;tt class="docutils literal"&gt;apply_async()&lt;/tt&gt; on the “task”, which returns an &lt;tt class="docutils literal"&gt;AsyncResult&lt;/tt&gt;, which
can be used to retrieve the result of that task, once it runs.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id8" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"/&gt;&lt;col/&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Note that Celery is frequently used with web frameworks that might run
on e.g. &lt;a class="reference external" href="https://gunicorn.org/"&gt;gunicorn&lt;/a&gt; with &lt;a class="reference external" href="http://docs.gunicorn.org/en/latest/design.html"&gt;async workers (using greenlets)&lt;/a&gt;, meaning that not
everything is blocked, but that is somewhat beyond the scope of this
post.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id9" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"/&gt;&lt;col/&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Twisted doesn’t &lt;a class="reference external" href="https://twistedmatrix.com/trac/wiki/FrequentlyAskedQuestions#HowdoIuseDeferredstomakemyblockingcodenon-blocking"&gt;magically make your code non-blocking&lt;/a&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id10" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"/&gt;&lt;col/&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Note that txCelery really only takes care of the second issue here.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id11" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"/&gt;&lt;col/&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id5"&gt;[5]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;Celery.send_task()&lt;/tt&gt; is a generic way to call a task by name without
importing it. It is generally useful, but in this particular case is a
nice spot to generically interrupt how Celery communicates to the
broker.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id12" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"/&gt;&lt;col/&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id6"&gt;[6]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Note that there are two different versions of the protocol, they’re
fairly similar, but version 2 moves some meta data from the body to the
headers to avoid needing to deserialize the entire message multiple
times. You can read &lt;a class="reference external" href="http://docs.celeryproject.org/en/latest/history/whatsnew-4.0.html#new-protocol-highlights"&gt;the highlights&lt;/a&gt; of the differences.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Patrick Cloke</dc:creator><pubDate>Tue, 23 Oct 2018 19:24:00 -0400</pubDate><guid isPermaLink="false">tag:patrick.cloke.us,2018-10-23:/posts/2018/10/23/calling-celery-from-twisted/</guid><category>articles</category><category>twisted</category><category>celery</category></item></channel></rss>