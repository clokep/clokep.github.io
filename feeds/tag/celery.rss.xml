<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Patrick Cloke - celery</title><link>https://patrick.cloke.us/</link><description></description><lastBuildDate>Mon, 24 May 2021 16:56:00 -0400</lastBuildDate><item><title>celery-batches 0.5 released!</title><link>https://patrick.cloke.us/posts/2021/05/24/celery-batches-0.5-released/</link><description>&lt;p&gt;A &lt;a class="reference external" href="https://pypi.org/project/celery-batches/0.5/"&gt;new version (v0.5)&lt;/a&gt; of &lt;a class="reference external" href="https://github.com/clokep/celery-batches/"&gt;celery-batches&lt;/a&gt; is available which adds support for
Celery 5.1 and fixes storing of results when using the &lt;a class="reference external" href="https://docs.celeryproject.org/en/v5.1.0/userguide/tasks.html#rpc-result-backend-rabbitmq-qpid"&gt;&lt;span class="caps"&gt;RPC&lt;/span&gt; result backend&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;As &lt;a class="reference external" href="https://patrick.cloke.us/posts/2019/10/04/celery-amqp-backends/"&gt;explored previously&lt;/a&gt;, the &lt;span class="caps"&gt;RPC&lt;/span&gt; result backend works by having a results queue
per client, unfortunately celery-batches was attempting to store the results in
a queue named after the task &lt;span class="caps"&gt;ID&lt;/span&gt; instead of the client &lt;span class="caps"&gt;ID&lt;/span&gt; (Celery internally calls
this the &amp;#8220;correlation &lt;span class="caps"&gt;ID&lt;/span&gt;&amp;#8221;) &lt;a class="footnote-reference" href="#id2" id="id1"&gt;[1]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This unfortunately requires a change to client code to pass the batched request
into the &lt;tt class="docutils literal"&gt;mark_as_done&lt;/tt&gt; method, using the example &lt;a class="reference external" href="https://celery-batches.readthedocs.io/en/v0.5/"&gt;from the documnation&lt;/a&gt; with
the changed line&amp;nbsp;highlighted:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;requests&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;urlparse&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;urlparse&lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;celery_batches&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Batches&lt;/span&gt;

&lt;span class="n"&gt;wot_api_target&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;https://api.mywot.com/0.4/public_link_json&amp;#39;&lt;/span&gt;

&lt;span class="nd"&gt;@app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;base&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;Batches&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;flush_every&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;flush_interval&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;wot_api&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;requests&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;sig&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt;
    &lt;span class="n"&gt;responses&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wot_api_real&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sig&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;request&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;requests&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c1"&gt;# use mark_as_done to manually return response data&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;request&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;zip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;responses&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;requests&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="hll"&gt;        &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;backend&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mark_as_done&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;wot_api_real&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;urls&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;domains&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;urlparse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;netloc&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;urls&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;requests&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;wot_api_target&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;hosts&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;domains&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;json&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;domain&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;domain&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;domains&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;table class="docutils footnote" frame="void" id="id2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;The &lt;span class="caps"&gt;RPC&lt;/span&gt; backend has &lt;a class="reference external" href="https://github.com/celery/celery/blob/v5.1.0/celery/backends/rpc.py#L166"&gt;code which pulls out the correlation &lt;span class="caps"&gt;ID&lt;/span&gt;&lt;/a&gt;, but falls
back to the task &lt;span class="caps"&gt;ID&lt;/span&gt; if not given. This is called via an
&lt;a class="reference external" href="https://github.com/celery/celery/blob/v5.1.0/celery/backends/rpc.py#L198-L200"&gt;override of the &lt;tt class="docutils literal"&gt;store_result&lt;/tt&gt; method&lt;/a&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Patrick Cloke</dc:creator><pubDate>Mon, 24 May 2021 16:56:00 -0400</pubDate><guid isPermaLink="false">tag:patrick.cloke.us,2021-05-24:/posts/2021/05/24/celery-batches-0.5-released/</guid><category>articles</category><category>celery</category><category>celery-batches</category></item><item><title>celery-batches 0.4 released!</title><link>https://patrick.cloke.us/posts/2020/11/30/celery-batches-0.4-released/</link><description>&lt;p&gt;Earlier today I released a version &lt;a class="reference external" href="https://pypi.org/project/celery-batches/0.4/"&gt;0.4&lt;/a&gt; of &lt;a class="reference external" href="https://github.com/clokep/celery-batches/"&gt;celery-batches&lt;/a&gt; with support for
Celery 5.0. As part of this release support for Python &amp;lt; 3.6 was dropped and
support for Celery &amp;lt; 4.4 was&amp;nbsp;dropped.&lt;/p&gt;
&lt;p&gt;celery-batches is a small library that allows you process multiple calls to a
&lt;a class="reference external" href="https://github.com/celery/celery/"&gt;Celery&lt;/a&gt; task together. The batches can be processed based on a count of task
calls or a timer. It started as an update of the &lt;tt class="docutils literal"&gt;celery.contrib.batches&lt;/tt&gt;
code to support Celery 4.0+ and has grown to support some additional&amp;nbsp;features.&lt;/p&gt;
&lt;p&gt;The project was also transferred on GitHub to my personal namespace (from my
previous employer). Realistically it was maintained by me already and this is
just a formality. As part of this release the &lt;a class="reference external" href="https://celery-batches.readthedocs.io/en/v0.4/"&gt;documentation&lt;/a&gt; is now available
on Read the&amp;nbsp;Docs.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Patrick Cloke</dc:creator><pubDate>Mon, 30 Nov 2020 16:50:00 -0500</pubDate><guid isPermaLink="false">tag:patrick.cloke.us,2020-11-30:/posts/2020/11/30/celery-batches-0.4-released/</guid><category>articles</category><category>celery</category><category>celery-batches</category></item><item><title>Celery AMQP Backends</title><link>https://patrick.cloke.us/posts/2019/10/04/celery-amqp-backends/</link><description>&lt;div class="admonition note"&gt;
&lt;p class="first admonition-title"&gt;Note&lt;/p&gt;
&lt;p class="last"&gt;This started as notes explaining the internals of how Celery&amp;#8217;s &lt;span class="caps"&gt;AMQP&lt;/span&gt; backends
operate. This isn&amp;#8217;t meant to be a comparison or prove one is better or that
one is broken. There just seemed to be a lack of documentation about the
design and limitations of each&amp;nbsp;backend.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Celery comes with &lt;a class="reference external" href="https://docs.celeryproject.org/en/latest/userguide/configuration.html#task-result-backend-settings"&gt;many results backends&lt;/a&gt;, two of which use &lt;span class="caps"&gt;AMQP&lt;/span&gt; under the
hood: the &amp;#8220;&lt;span class="caps"&gt;AMQP&lt;/span&gt;&amp;#8221; and &amp;#8220;&lt;span class="caps"&gt;RPC&lt;/span&gt;&amp;#8221; backends. Both of them publish results as messages
into &lt;span class="caps"&gt;AMQP&lt;/span&gt; queues. They&amp;#8217;re convenient since you only need one piece of
infrastructure to handle both tasks and results (e.g. &lt;a class="reference external" href="https://www.rabbitmq.com/"&gt;RabbitMQ&lt;/a&gt;). Check the
&lt;a class="reference external" href="https://docs.celeryproject.org/en/latest/userguide/configuration.html#result-backend"&gt;&lt;tt class="docutils literal"&gt;result_backend&lt;/tt&gt;&lt;/a&gt; setting if you&amp;#8217;re unsure what you&amp;#8217;re&amp;nbsp;using!&lt;/p&gt;
&lt;div class="section" id="amqp-backend"&gt;
&lt;h2&gt;&lt;span class="caps"&gt;AMQP&lt;/span&gt;&amp;nbsp;backend&lt;/h2&gt;
&lt;p&gt;The &lt;a class="reference external" href="https://docs.celeryproject.org/en/latest/internals/reference/celery.backends.amqp.html"&gt;&lt;span class="caps"&gt;AMQP&lt;/span&gt; backend&lt;/a&gt; is deprecated, it uses a results queue &lt;strong&gt;per task call&lt;/strong&gt;,
this doesn&amp;#8217;t scale well since there is significant overhead (many queues, many
bindings, etc.). That&amp;#8217;s pretty much all I know about it, I&amp;#8217;ve never used&amp;nbsp;it.&lt;/p&gt;
&lt;p&gt;A system level view is&amp;nbsp;below:&lt;/p&gt;
&lt;blockquote class="text-center"&gt;
&lt;a class="reference external image-reference" href="https://patrick.cloke.us/images/celery-amqp-backends/amqp-backend.png"&gt;&lt;img alt="RPC requeueing behavior" src="https://patrick.cloke.us/images/celery-amqp-backends/amqp-backend.png" style="width: 80%;" /&gt;&lt;/a&gt;
&lt;/blockquote&gt;
&lt;p&gt;The caller produces a task into the task queue. The worker consumes the task
from this queue and creates a result, which is added to a separate results queue
per task call. In the example above there&amp;#8217;s tasks A, B, C, etc. Each of those
produces a result (A&amp;#8217;, B&amp;#8217;, C&amp;#8217;, etc.) in separate&amp;nbsp;queues.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="rpc-backend"&gt;
&lt;h2&gt;&lt;span class="caps"&gt;RPC&lt;/span&gt;&amp;nbsp;backend&lt;/h2&gt;
&lt;p&gt;The &lt;a class="reference external" href="https://docs.celeryproject.org/en/latest/internals/reference/celery.backends.rpc.html"&gt;&lt;span class="caps"&gt;RPC&lt;/span&gt; backend&lt;/a&gt; uses a results queue &lt;strong&gt;per client&lt;/strong&gt; which scales better, but
is a bit more limited in functionality &amp;#8212; it assumes that the process that
produces the task also consumes the result (hence the &amp;#8220;&lt;span class="caps"&gt;RPC&lt;/span&gt;&amp;#8221; name &amp;#8212; referring to
&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Remote_procedure_call"&gt;remote procedure call&lt;/a&gt;). See the &lt;a class="reference external" href="https://docs.celeryproject.org/en/latest/history/whatsnew-3.1.html#new-rpc-result-backend"&gt;announcement of the &lt;span class="caps"&gt;RPC&lt;/span&gt; backend&lt;/a&gt; for more&amp;nbsp;information.&lt;/p&gt;
&lt;p&gt;A system level view is&amp;nbsp;below:&lt;/p&gt;
&lt;blockquote class="text-center"&gt;
&lt;a class="reference external image-reference" href="https://patrick.cloke.us/images/celery-amqp-backends/rpc-backend.png"&gt;&lt;img alt="RPC requeueing behavior" src="https://patrick.cloke.us/images/celery-amqp-backends/rpc-backend.png" style="width: 80%;" /&gt;&lt;/a&gt;
&lt;/blockquote&gt;
&lt;p&gt;The caller produces a task into the task queue. The worker consumes the task
from this queue and creates a result, which is added to a results queue per
caller. In the example above there&amp;#8217;s tasks A, B, C, etc. Each of those
produces a result (A&amp;#8217;, B&amp;#8217;, C&amp;#8217;, etc.) in the same&amp;nbsp;queue.&lt;/p&gt;
&lt;p&gt;Since the results go into a queue per caller, this works well when the caller
(and only the caller) is what needs to consume the&amp;nbsp;result.&lt;/p&gt;
&lt;p&gt;Other things to note with the &lt;span class="caps"&gt;RPC&lt;/span&gt;&amp;nbsp;backend:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Each result can only be consumed once (since it is then removed from the
results&amp;nbsp;queue).&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://docs.celeryproject.org/en/latest/userguide/canvas.html#chords"&gt;chords&lt;/a&gt; are not supported (but that is not something that I&amp;#8217;ve ever&amp;nbsp;used).&lt;/li&gt;
&lt;li&gt;Results are discarded when the client disconnects or if the broker restarts
(they&amp;#8217;re not&amp;nbsp;durable).&lt;/li&gt;
&lt;li&gt;If there is too much &amp;#8220;state history&amp;#8221; (if the results queue grows too large), a
&lt;a class="reference external" href="https://docs.celeryproject.org/en/latest/internals/reference/celery.backends.rpc.html#celery.backends.rpc.BacklogLimitExceeded"&gt;&lt;tt class="docutils literal"&gt;BacklogLimitExceeded&lt;/tt&gt;&lt;/a&gt; exception will be raised. (By default too large is
1000 pending task&amp;nbsp;results.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The &lt;span class="caps"&gt;RPC&lt;/span&gt; backend can run into issues with &lt;span class="caps"&gt;AMQP&lt;/span&gt; queues being &lt;a class="reference external" href="https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)"&gt;&lt;span class="caps"&gt;FIFO&lt;/span&gt;&lt;/a&gt; &amp;#8212; if two
tasks (A &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; B) are started and task B finishes before A, but the client tries to
get the result of task A first&amp;#8230;what happens? The &lt;span class="caps"&gt;RPC&lt;/span&gt; backend does one of two&amp;nbsp;things:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Requeues it (the&amp;nbsp;default).&lt;/li&gt;
&lt;li&gt;Caches it locally until it is&amp;nbsp;needed.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The requeuing behavior is shown&amp;nbsp;below:&lt;/p&gt;
&lt;blockquote class="text-center"&gt;
&lt;a class="reference external image-reference" href="https://patrick.cloke.us/images/celery-amqp-backends/rpc-requeues.png"&gt;&lt;img alt="RPC requeueing behavior" src="https://patrick.cloke.us/images/celery-amqp-backends/rpc-requeues.png" style="width: 50%;" /&gt;&lt;/a&gt;
&lt;/blockquote&gt;
&lt;p&gt;In the example above, result B was added into the queue before A, but A is
needed first. The queue is run down until A is received and all other items are
requeued (onto the back of the&amp;nbsp;queue).&lt;/p&gt;
&lt;p&gt;If you have many parallel tasks running this can cause issues, either by running
into the &lt;tt class="docutils literal"&gt;BacklogLimitExceeded&lt;/tt&gt; error or just lots of churn in the queue
(meaning lots of&amp;nbsp;I/O).&lt;/p&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Patrick Cloke</dc:creator><pubDate>Fri, 04 Oct 2019 08:10:00 -0400</pubDate><guid isPermaLink="false">tag:patrick.cloke.us,2019-10-04:/posts/2019/10/04/celery-amqp-backends/</guid><category>articles</category><category>celery</category></item><item><title>Celery without a Results Backend</title><link>https://patrick.cloke.us/posts/2019/07/17/celery-without-a-results-backend/</link><description>&lt;p&gt;The &lt;a class="reference external" href="http://www.celeryproject.org/"&gt;Celery&lt;/a&gt; &lt;a class="reference external" href="https://docs.celeryproject.org/en/latest/reference/celery.html#celery.Celery.send_task"&gt;&lt;tt class="docutils literal"&gt;send_task&lt;/tt&gt;&lt;/a&gt; method allows you to invoke a task by name without
importing it. &lt;a class="footnote-reference" href="#id5" id="id1"&gt;[1]&lt;/a&gt; There is an undocumented &lt;a class="footnote-reference" href="#id6" id="id2"&gt;[2]&lt;/a&gt; caveat to using &lt;tt class="docutils literal"&gt;send_task&lt;/tt&gt;:
it doesn&amp;#8217;t have access to the configuration of the task (from when the task was
created using the &lt;a class="reference external" href="https://docs.celeryproject.org/en/latest/reference/celery.html#celery.Celery.task"&gt;&lt;tt class="docutils literal"&gt;&amp;#64;task&lt;/tt&gt; decorator&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Much of this configuration doesn&amp;#8217;t matter to the caller, for example the caller
doesn&amp;#8217;t care&amp;nbsp;about:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Whether the task is bound or&amp;nbsp;not.&lt;/li&gt;
&lt;li&gt;The retry configuration of&amp;nbsp;tasks.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There is also configuration from the caller that &lt;em&gt;must&lt;/em&gt; be right for the task to
execute as you&amp;#8217;d&amp;nbsp;expect:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;The number of arguments and the keywords for any keyword&amp;nbsp;arguments.&lt;/li&gt;
&lt;li&gt;The serializer or compressor must match what the worker can&amp;nbsp;handle.&lt;/li&gt;
&lt;li&gt;If a non-default results backend is to be&amp;nbsp;used.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Another piece of configuration that matters (which surprised me and had a
performance impact for us &lt;a class="footnote-reference" href="#id7" id="id3"&gt;[3]&lt;/a&gt;) is whether to ignore a task result or not.
Unexpectedly, Celery will attempt to connect to the results backend &lt;em&gt;on task call&lt;/em&gt;.
I assumed that the results backend would never be contaced since we never
attempted to &lt;strong&gt;retrieve&lt;/strong&gt; a result! This turned out to be&amp;nbsp;untrue.&lt;/p&gt;
&lt;p&gt;Once identified, The fix was straightforward! We ensured that every task which
had &lt;tt class="docutils literal"&gt;ignore_result=True&lt;/tt&gt; on task declaration also had &lt;tt class="docutils literal"&gt;ignore_result=True&lt;/tt&gt;
on task call (when using &lt;tt class="docutils literal"&gt;send_task&lt;/tt&gt;). &lt;a class="footnote-reference" href="#id8" id="id4"&gt;[4]&lt;/a&gt; This duplciation is unfortunate,
but easy&amp;nbsp;enough.&lt;/p&gt;
&lt;p&gt;We figured this out due to a calling process which doesn&amp;#8217;t use any results, but
the &lt;tt class="docutils literal"&gt;celery.backends&lt;/tt&gt; module was appearing in the &lt;a class="reference external" href="https://pyflame.readthedocs.io"&gt;pyflame&lt;/a&gt; profiles.
Another solution (for this particular setup) was to use the (&lt;a class="reference external" href="http://docs.celeryproject.org/en/latest/userguide/configuration.html#task-result-backend-settings"&gt;undocumented&lt;/a&gt;)
&lt;tt class="docutils literal"&gt;disabled&lt;/tt&gt; results&amp;nbsp;backend.&lt;/p&gt;
&lt;table class="docutils footnote" frame="void" id="id5" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;There are a variety of reasons you might want to do this, but I&amp;#8217;ve
used it when tasks that use &lt;a class="reference external" href="https://www.djangoproject.com/"&gt;Django&lt;/a&gt; models but the calling process
does not have Django configured.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id6" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;I couldn&amp;#8217;t find any documentation about it at least. Maybe this is meant
to be obvious, but it didn&amp;#8217;t click for me without deep understanding of
how Celery works.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id7" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;The performance impact we were seeing was due to the &lt;span class="caps"&gt;TCP&lt;/span&gt; negotiation and
login to the results backend. This got especially bad if the results
backend was under load or down.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id8" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Note that it is a &lt;a class="reference external" href="https://docs.celeryproject.org/en/latest/userguide/tasks.html?highlight=argsrepr#ignore-results-you-don-t-want"&gt;best practice&lt;/a&gt; to ignore results on tasks where you
don&amp;#8217;t need the result!&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Patrick Cloke</dc:creator><pubDate>Wed, 17 Jul 2019 20:35:00 -0400</pubDate><guid isPermaLink="false">tag:patrick.cloke.us,2019-07-17:/posts/2019/07/17/celery-without-a-results-backend/</guid><category>articles</category><category>celery</category></item><item><title>Calling Celery from Twisted</title><link>https://patrick.cloke.us/posts/2018/10/23/calling-celery-from-twisted/</link><description>
&lt;div class="section" id="background"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id13"&gt;Background&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I use &lt;a class="reference external" href="https://twistedmatrix.com/"&gt;Twisted&lt;/a&gt; and &lt;a class="reference external" href="http://www.celeryproject.org/"&gt;Celery&lt;/a&gt; daily at work, both are useful frameworks, both have
a lot of great information out there, but a particular use (that I haven’t seen
discussed much online, hence this post) is calling Celery tasks &lt;em&gt;from&lt;/em&gt; Twisted
(and subsequently using the result).&lt;/p&gt;
&lt;p&gt;The difference between Twisted and Celery seems to be a frequent question people
have (check out the number of questions on &lt;a class="reference external" href="https://stackoverflow.com/search?q=twisted+or+celery"&gt;StackOverflow&lt;/a&gt;). The main difference,
from my point of view, is that Twisted is a “batteries included” networking
framework that is asynchronous / evented for handling of I/O, Celery is a &lt;em&gt;distributed&lt;/em&gt;
task queue which excels at short &lt;span class="caps"&gt;CPU&lt;/span&gt;-bound tasks where the asynchronous nature
comes from running multiple processes. The &lt;a class="reference external" href="https://github.com/SentimensRG/txCelery"&gt;txCelery&lt;/a&gt; project has a nice summary
on their page:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Celery is an outstanding choice for dispatching &lt;em&gt;short-lived&lt;/em&gt;,
computationally-expensive tasks to a distributed backend system. Note the
emphasis; Celery is ill-suited for tasks tasks that require updating some
in-memory representation with out-of-process data. If you want a specific
process to read data from standard input, for instance, good luck…&lt;/p&gt;
&lt;p&gt;Twisted can be though of as having the opposite problem. Twisted is very
good at maintaining and updating in-memory representations over extended
periods of time, but fails miserably at performing expensive computations.
Twisted notably has no built-in constructs for managing distributed task queues.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The two main ways to interact with Celery are:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Call a task (and have it happen asynchronously).&lt;/li&gt;
&lt;li&gt;Get the result of that task.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In order to call Celery from Twisted we’ll need to ensure that both of these can
happen in a way that matches Twisted’s execution model. This might be
illustrated best by a code example, we would want to do something like the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;celery&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Celery&lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;twisted.internet&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;defer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;task&lt;/span&gt;

&lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Celery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;broker&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'amqp://guest:guest@127.0.0.1:5672//'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;backend&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'rpc'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nd"&gt;@app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;my_task&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c1"&gt;# Normally you'd do a CPU bound task here.&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;

&lt;span class="nd"&gt;@defer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;inlineCallbacks&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="c1"&gt;# Normally you'd open some listening sockets or some outbound&lt;/span&gt;
    &lt;span class="c1"&gt;# connections here.&lt;/span&gt;

    &lt;span class="c1"&gt;# Call into Celery!&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;my_task&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c1"&gt;# Should print '1 + 2 = 3'.&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s2"&gt; + &lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s2"&gt; = &lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;react&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="initial-approach"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id14"&gt;Initial Approach&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The initial attempt to pair these libraries is to call Celery tasks like you
would normally (import the Celery task and call &lt;a class="reference external" href="http://docs.celeryproject.org/en/latest/reference/celery.app.task.html#celery.app.task.Task.delay"&gt;&lt;tt class="docutils literal"&gt;delay()&lt;/tt&gt;&lt;/a&gt; on it). &lt;a class="footnote-reference" href="#id7" id="id1"&gt;[1]&lt;/a&gt; There’s
a hint that this won’t work in &lt;a class="reference external" href="http://docs.celeryproject.org/en/latest/reference/celery.app.task.html#celery.app.task.Task.delay"&gt;the documentation&lt;/a&gt; however:&lt;/p&gt;
&lt;blockquote&gt;
Apply tasks asynchronously by sending a message.&lt;/blockquote&gt;
&lt;p&gt;The documentation around calling &lt;a class="reference external" href="http://docs.celeryproject.org/en/latest/reference/celery.result.html#celery.result.AsyncResult.get"&gt;&lt;tt class="docutils literal"&gt;AsyncResult.get()&lt;/tt&gt;&lt;/a&gt;, to retrieve the result
also hints about issues:&lt;/p&gt;
&lt;blockquote&gt;
Wait until task is ready, and return its result.&lt;/blockquote&gt;
&lt;p&gt;It isn’t incredibly clear from the documentation, but this points to two
separate issues with calling Celery from Twisted:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;In both of these situations, (synchronous) I/O is happening in the
background when you make this call! &lt;a class="footnote-reference" href="#id8" id="id2"&gt;[2]&lt;/a&gt; I/O happening outside of the
reactor is a big no-no in a Twisted process since it can block the reactor
from running. &lt;a class="footnote-reference" href="#id9" id="id3"&gt;[3]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Additionally, the &lt;tt class="docutils literal"&gt;AsyncResult.get()&lt;/tt&gt; call blocks until a result is ready,
this doesn’t fit well into an evented programming paradigm. &lt;a class="footnote-reference" href="#id10" id="id4"&gt;[4]&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The second problem is handled well by the &lt;a class="reference external" href="https://github.com/SentimensRG/txCelery"&gt;txCelery&lt;/a&gt; package, it allows you to
call a task and get a sub-class of &lt;a class="reference external" href="http://twistedmatrix.com/documents/current/api/twisted.internet.defer.Deferred.html"&gt;&lt;tt class="docutils literal"&gt;Deferred&lt;/tt&gt;&lt;/a&gt; which resolves into the result
of the task call by periodically monitoring the status of the result.&lt;/p&gt;
&lt;p&gt;Unfortunately txCelery doesn’t solve the first issue (to my knowledge) since it
just uses the normal mechanisms built into Celery for I/O (which causes I/O in
the reactor thread).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="threaded-approach"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id15"&gt;Threaded Approach&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Twisted has a thread pool and makes it super easy to ask it to “run this code in
a non-reactor thread and return the result to me”. It is pretty straightforward
to cobble together a way to use &lt;a class="reference external" href="https://twistedmatrix.com/documents/current/api/twisted.internet.threads.html#deferToThread"&gt;&lt;tt class="docutils literal"&gt;threads.deferToThread()&lt;/tt&gt;&lt;/a&gt; to call
&lt;a class="reference external" href="http://docs.celeryproject.org/en/latest/reference/celery.html#celery.Celery.send_task"&gt;&lt;tt class="docutils literal"&gt;Celery.send_task()&lt;/tt&gt;&lt;/a&gt; &lt;a class="footnote-reference" href="#id11" id="id5"&gt;[5]&lt;/a&gt;. You still need an asynchronous way to check if the
task result is ready, however. You could just call &lt;tt class="docutils literal"&gt;AsyncResult.get()&lt;/tt&gt; in a
thread, but you will likely quickly exhaust your thread pool since that blocks
until a result is ready. Alternately you can check the status of a task using
the &lt;a class="reference external" href="http://docs.celeryproject.org/en/latest/reference/celery.result.html#celery.result.AsyncResult.state"&gt;&lt;tt class="docutils literal"&gt;state&lt;/tt&gt;&lt;/a&gt; property of an &lt;tt class="docutils literal"&gt;AsyncResult&lt;/tt&gt;. (I found it very surprising that
accessing a &lt;em&gt;property&lt;/em&gt; of this object causes I/O to happen, but it does.)&lt;/p&gt;
&lt;p&gt;Connecting these ideas together we came up with something similar to the
following (note that this is heavily inspired by what txCelery does, but pushes
all I/O onto a separate thread instead of doing it in the reactor thread):&lt;/p&gt;
&lt;pre class="code python highlight literal-block"&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;celery&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;states&lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;twisted.internet&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;defer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;reactor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;threads&lt;/span&gt;


&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;send_task&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c1"&gt;# Call the real function via a background thread.&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;threads&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;deferToThread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send_task&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;addCallback&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CeleryDeferred&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;CeleryDeferred&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;defer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Deferred&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;"""
    Extension of the Twisted Deferred object that wraps a Celery AsyncResult.

    This Deferred will occasionally poll the Celery task for its status. When
    complete, the Deferred will resolve and any added callbacks will be run.

    Inspired by txCelery: https://github.com/SentimensRG/txCelery/
    """&lt;/span&gt;
    &lt;span class="n"&gt;CHECK_INTERVAL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.25&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;async_result&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="c1"&gt;# Deferred is an old-style class&lt;/span&gt;
        &lt;span class="n"&gt;defer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Deferred&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_canceller&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;async_result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;async_result&lt;/span&gt;
        &lt;span class="c1"&gt;# Start the monitor loop&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;check_state&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;check_state&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;"""Check the status of the celery task on another thread."""&lt;/span&gt;
        &lt;span class="n"&gt;threads&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;deferToThread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_state&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;addCallbacks&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state_received&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;errback&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;get_state&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;"""Check the status of the celery task directly"""&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;async_result&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;state_received&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;celery_state&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;"""Called when the check_state thread finishes"""&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;celery_state&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;states&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;UNREADY_STATES&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="c1"&gt;# Schedule another status check, to be run later.&lt;/span&gt;
            &lt;span class="n"&gt;reactor&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;callLater&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CHECK_INTERVAL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;check_state&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;celery_state&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;states&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SUCCESS&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;callback&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;async_result&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;celery_state&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;states&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FAILURE&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="c1"&gt;# This will contain the Exception instance if the task raised one&lt;/span&gt;
            &lt;span class="c1"&gt;# http://docs.celeryproject.org/en/latest/reference/celery.result.html&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;errback&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;async_result&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;celery_state&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;states&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;REVOKED&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;errback&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;defer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CancelledError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Task &lt;/span&gt;&lt;span class="si"&gt;{0}&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;async_result&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="c1"&gt;# An unknown state was returned.&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;errback&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ne"&gt;ValueError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Unknown state: `&lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s1"&gt;`'&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;celery_state&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;_canceller&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="c1"&gt;# Revoke the celery task&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;async_result&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;revoke&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;The calling syntax of this isn’t as nice as the initial approach, but it is
pretty close (the modified lines are highlighted):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;celery&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Celery&lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;twisted.internet&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;defer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;task&lt;/span&gt;
&lt;span class="hll"&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;twistedcelery&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;send_task&lt;/span&gt;
&lt;/span&gt;
&lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Celery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;broker&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'amqp://guest:guest@127.0.0.1:5672//'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;backend&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'rpc'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nd"&gt;@app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;my_task&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c1"&gt;# Normally you'd do a CPU bound task here.&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;

&lt;span class="nd"&gt;@defer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;inlineCallbacks&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="c1"&gt;# Normally you'd open some listening sockets or some outbound&lt;/span&gt;
    &lt;span class="c1"&gt;# connections here.&lt;/span&gt;

    &lt;span class="c1"&gt;# Call into Celery!&lt;/span&gt;
&lt;span class="hll"&gt;    &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;send_task&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'my_task'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/span&gt;    &lt;span class="c1"&gt;# Should print '1 + 2 = 3'.&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s2"&gt; + &lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s2"&gt; = &lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;react&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="twisted-native-approach"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id16"&gt;Twisted-native Approach&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I think the above solutions are fundamentally wrong, but are easy-ish to
implement. They might work &lt;span class="caps"&gt;OK&lt;/span&gt; for small loads, or if increased latency is
acceptable, but will start to fail when a large number of pending tasks are
necessary. A better way is to consider:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Celery is designed to be &lt;a class="reference external" href="http://docs.celeryproject.org/en/latest/faq.html#is-celery-dependent-on-pickle"&gt;language&lt;/a&gt; &lt;a class="reference external" href="http://docs.celeryproject.org/en/latest/faq.html#is-celery-multilingual"&gt;independent&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Celery &lt;a class="reference external" href="http://docs.celeryproject.org/en/latest/internals/protocol.html"&gt;message formats&lt;/a&gt; are part of the public “&lt;span class="caps"&gt;API&lt;/span&gt;”. &lt;a class="footnote-reference" href="#id12" id="id6"&gt;[6]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Celery uses standard networking protocols to enable distributed processing.&lt;/li&gt;
&lt;li&gt;Twisted is designed to efficiency implement networking protocols.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This lead me to the conclusion that Twisted can just treat Celery tasks as if it
is implemented in a different language and just try to directly communicate with
the Celery broker and backend. It can just send task calls and query for
responses, when available. We can be a little bit more clever, however, and use
Celery to process the details of the messages to send, the queue to send them
to, etc.&lt;/p&gt;
&lt;p&gt;The hope is to end up with code like this (again, modified lines are highlighted):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;celery&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Celery&lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;twisted.internet&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;defer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;task&lt;/span&gt;
&lt;span class="hll"&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;twistedcelery&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;TwistedCelery&lt;/span&gt;
&lt;/span&gt;
&lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Celery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;broker&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'amqp://guest:guest@127.0.0.1:5672//'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;backend&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'rpc'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nd"&gt;@app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;my_task&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c1"&gt;# Normally you'd do a CPU bound task here.&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;

&lt;span class="nd"&gt;@defer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;inlineCallbacks&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="c1"&gt;# Normally you'd open some listening sockets or some outbound&lt;/span&gt;
    &lt;span class="c1"&gt;# connections here.&lt;/span&gt;

&lt;span class="hll"&gt;    &lt;span class="c1"&gt;# Turn the Celery app into a TwistedCelery app, which uses Twisted to do&lt;/span&gt;
&lt;/span&gt;&lt;span class="hll"&gt;    &lt;span class="c1"&gt;# I/O under the hood.&lt;/span&gt;
&lt;/span&gt;&lt;span class="hll"&gt;    &lt;span class="n"&gt;tx_app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TwistedCelery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;
    &lt;span class="c1"&gt;# Call into Celery!&lt;/span&gt;
&lt;span class="hll"&gt;    &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;tx_app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send_task&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'my_task'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/span&gt;    &lt;span class="c1"&gt;# Should print '1 + 2 = 3'.&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s2"&gt; + &lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s2"&gt; = &lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;react&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I’ve started the &lt;a class="reference external" href="https://github.com/clokep/twistedcelery"&gt;Twisted-Celery&lt;/a&gt; project in order to accomplish this goal. It
uses Celery to create the messages and to decide what exchange/queue/etc. to
use, but allows Twisted to handle all communication to your configured Celery
broker and backend. It exposes a &lt;tt class="docutils literal"&gt;send_task()&lt;/tt&gt; compatible &lt;span class="caps"&gt;API&lt;/span&gt;, but returns a
&lt;tt class="docutils literal"&gt;Deferred&lt;/tt&gt; instead of an &lt;tt class="docutils literal"&gt;AsyncResult&lt;/tt&gt; so you can write Twisted-compatible
code easily.&lt;/p&gt;
&lt;p&gt;It is just a proof of concept right now, but was successfully tested on a real
project. Note that it currently only supports &lt;span class="caps"&gt;AMQP&lt;/span&gt;, but this should be
expandable to other brokers. I won’t go into the details of how it works here,
but the hope is that you can give it a configured Celery app and it “just works”
with Twisted.&lt;/p&gt;
&lt;p&gt;If you’re interested in helping out, checkout the &lt;a class="reference external" href="https://github.com/clokep/twistedcelery"&gt;GitHub repository&lt;/a&gt; or leave a
comment below.&lt;/p&gt;
&lt;table class="docutils footnote" frame="void" id="id7" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"/&gt;&lt;col/&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;If you’re unfamiliar with Celery, briefly it allows a “task” is defined
in Python code, a “worker” is used to execute those tasks. The code
which wants to execute those tasks calls &lt;tt class="docutils literal"&gt;delay()&lt;/tt&gt; or
&lt;tt class="docutils literal"&gt;apply_async()&lt;/tt&gt; on the “task”, which returns an &lt;tt class="docutils literal"&gt;AsyncResult&lt;/tt&gt;, which
can be used to retrieve the result of that task, once it runs.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id8" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"/&gt;&lt;col/&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Note that Celery is frequently used with web frameworks that might run
on e.g. &lt;a class="reference external" href="https://gunicorn.org/"&gt;gunicorn&lt;/a&gt; with &lt;a class="reference external" href="http://docs.gunicorn.org/en/latest/design.html"&gt;async workers (using greenlets)&lt;/a&gt;, meaning that not
everything is blocked, but that is somewhat beyond the scope of this
post.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id9" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"/&gt;&lt;col/&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Twisted doesn’t &lt;a class="reference external" href="https://twistedmatrix.com/trac/wiki/FrequentlyAskedQuestions#HowdoIuseDeferredstomakemyblockingcodenon-blocking"&gt;magically make your code non-blocking&lt;/a&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id10" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"/&gt;&lt;col/&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Note that txCelery really only takes care of the second issue here.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id11" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"/&gt;&lt;col/&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id5"&gt;[5]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;Celery.send_task()&lt;/tt&gt; is a generic way to call a task by name without
importing it. It is generally useful, but in this particular case is a
nice spot to generically interrupt how Celery communicates to the
broker.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id12" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"/&gt;&lt;col/&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id6"&gt;[6]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Note that there are two different versions of the protocol, they’re
fairly similar, but version 2 moves some meta data from the body to the
headers to avoid needing to deserialize the entire message multiple
times. You can read &lt;a class="reference external" href="http://docs.celeryproject.org/en/latest/history/whatsnew-4.0.html#new-protocol-highlights"&gt;the highlights&lt;/a&gt; of the differences.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Patrick Cloke</dc:creator><pubDate>Tue, 23 Oct 2018 19:24:00 -0400</pubDate><guid isPermaLink="false">tag:patrick.cloke.us,2018-10-23:/posts/2018/10/23/calling-celery-from-twisted/</guid><category>articles</category><category>twisted</category><category>celery</category></item></channel></rss>